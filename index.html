<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cut Inside - Keyword Cannibalisation Visualiser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Familjen+Grotesk:wght@600;700&family=Montserrat:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --ci-black: #1A1A18;
            --ci-white: #FFFFFF;
            --ci-grey: #E8E8E8;
            --ci-teal: #008080;
            --ci-pattens-blue: #DEF4F4;
            --ci-pink: #FFCAF7;
            --ci-yellow: #FDD401;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--ci-pattens-blue);
            color: var(--ci-black);
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Familjen Grotesk', sans-serif;
        }
        .brand-h1 {
            font-family: 'Familjen Grotesk', sans-serif;
            font-weight: 700;
            color: var(--ci-teal);
        }
         .brand-h2 {
            font-family: 'Familjen Grotesk', sans-serif;
            font-weight: 700;
            color: var(--ci-black);
        }
        .brand-subtitle {
            font-family: 'Familjen Grotesk', sans-serif;
            font-weight: 600;
        }

        .light-card {
            background-color: var(--ci-white);
            border: 1px solid var(--ci-grey);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
        }
        .metric-button, .filter-button {
            font-family: 'Montserrat', sans-serif;
            font-weight: 500;
            border: 1px solid var(--ci-teal);
            color: var(--ci-teal);
            background-color: var(--ci-white);
            transition: all 0.2s ease-in-out;
        }
        .metric-button.active, .filter-button.active,
        .metric-button:hover:not(.active), .filter-button:hover:not(.active) {
            background-color: var(--ci-teal);
            color: var(--ci-white);
        }
         .primary-action-button {
            font-family: 'Montserrat', sans-serif;
            font-weight: 500;
            background-color: var(--ci-teal);
            color: var(--ci-white);
            border: 1px solid var(--ci-teal);
        }
        .primary-action-button:hover {
            background-color: #006666;
        }


        .keyword-item {
            border-bottom: 1px solid var(--ci-grey);
        }
        .keyword-item:last-child {
            border-bottom: none;
        }
        .keyword-item:hover {
            background-color: var(--ci-pattens-blue);
        }
        .keyword-item.active {
            background-color: var(--ci-teal);
            color: var(--ci-white);
        }
        .keyword-item.active .text-slate-400 {
            color: var(--ci-white) !important;
        }


        #keywordListContainer {
            max-height: 400px; 
            overflow-y: auto;
        }
        @media (min-width: 1024px) { 
             #keywordListContainer { max-height: 500px; }
        }

        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext {
            visibility: hidden; min-width: 140px; background-color: var(--ci-black); color: var(--ci-white);
            text-align: center; border-radius: 6px; padding: 5px 8px; position: absolute;
            z-index: 10; bottom: 125%; left: 50%; margin-left: -70px; opacity: 0; transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--ci-pattens-blue); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #a0aec0; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }

        .loader {
            border: 5px solid var(--ci-grey); border-top: 5px solid var(--ci-teal); border-radius: 50%;
            width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .message-box {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: var(--ci-white); padding: 1rem; border-radius: 0.5rem; z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: none; 
        }
        .badge-container { display: flex; gap: 0.25rem; }
        #chartBadgesContainer .tooltip { margin-left: 0.5rem; }

        .clickable-count { cursor: pointer; text-decoration: underline; color: var(--ci-teal); }
        .clickable-count:hover { color: #006666; }

        .table-url-link { color: var(--ci-teal); text-decoration: none; }
        .table-url-link:hover { color: #006666; text-decoration: underline; }

        .invalid-regex { border-color: var(--ci-yellow) !important; }
        
        .custom-input {
            background-color: var(--ci-white);
            border: 1px solid var(--ci-grey);
            color: var(--ci-black);
        }
        .custom-input:focus {
            border-color: var(--ci-teal);
            ring-color: var(--ci-teal);
        }
        .custom-select {
             background-color: var(--ci-white);
             border: 1px solid var(--ci-grey);
             color: var(--ci-black);
        }
        .custom-select:focus {
            border-color: var(--ci-teal);
            outline-color: var(--ci-teal);
        }
        .file-input-button {
            background-color: var(--ci-teal) !important;
            color: var(--ci-white) !important;
            border: 1px solid var(--ci-teal) !important;
        }
        .file-input-button:hover {
             background-color: #006666 !important;
        }
        .badge-warning {
            background-color: var(--ci-yellow);
            color: var(--ci-black);
        }
         .badge-cannibalization {
            background-color: var(--ci-pink);
            color: var(--ci-black);
        }

    </style>
</head>
<body class="p-4 md:p-8">
    <div id="messageBox" class="message-box"></div>
    <header class="mb-12 text-center">
        <img src="https://cutinside.com/wp-content/uploads/2025/01/Logo.svg" alt="Cut Inside Logo" class="h-16 mx-auto mb-4">
        <h1 class="brand-h1 text-3xl md:text-4xl">Keyword Cannibalisation Visualiser</h1>
        <p class="text-slate-600 mt-2 text-sm">Upload your GSC CSV to identify and visualize keyword cannibalisation.</p>
    </header>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <div class="light-card p-6">
            <h2 class="brand-h2 text-xl font-semibold mb-3">1. Upload GSC Data</h2>
            <input type="file" id="csvFileInput" accept=".csv" class="block w-full text-sm text-gray-700 custom-input
                file:mr-4 file:py-2 file:px-4
                file:rounded-md file:border-0
                file:text-sm file:font-semibold
                file-input-button cursor-pointer"/>
            <p id="fileInfo" class="text-xs text-gray-500 mt-2">Upload a CSV export from Google Search Console.</p>
            <div id="loadingIndicator" class="loader" style="display: none;"></div>
        </div>

        <div class="light-card p-6">
            <h2 class="brand-h2 text-xl font-semibold mb-3">2. Filter Options</h2>
            <div class="flex">
                <input type="text" id="keywordFilterInput" placeholder="Enter keyword or regex..." class="w-full p-2 rounded-l-md custom-input focus:border-[var(--ci-teal)] focus:ring-[var(--ci-teal)] outline-none">
                <button id="clearFilterButton" class="p-2 primary-action-button rounded-r-md">Clear</button>
            </div>
            <p id="keywordCountText" class="text-xs text-gray-500 mt-2">Showing 0 keywords.</p>
            
            <div id="countryFilterContainer" class="mt-4" style="display: none;">
                <label for="countryFilterSelect" class="block text-sm font-medium text-gray-700 brand-subtitle mb-1">Filter Chart/Table by Country:</label>
                <select id="countryFilterSelect" class="w-full p-2 rounded-md custom-select">
                </select>
            </div>
        </div>

        <div class="light-card p-6">
            <h2 class="brand-h2 text-xl font-semibold mb-3">3. Metric to Visualize</h2>
            <div id="metricButtons" class="grid grid-cols-2 sm:grid-cols-4 gap-2">
                <button data-metric="Clicks" class="metric-button p-2 rounded-md active">Clicks</button>
                <button data-metric="Impressions" class="metric-button p-2 rounded-md">Impressions</button>
                <button data-metric="CTR" class="metric-button p-2 rounded-md">CTR (%)</button>
                <button data-metric="Position" class="metric-button p-2 rounded-md">Position</button>
            </div>
        </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div class="lg:col-span-1 light-card p-6 flex flex-col">
            <h2 class="brand-h2 text-xl font-semibold mb-4">Keywords with Multiple URLs</h2>
            <div id="keywordListContainer" class="space-y-1 flex-grow">
                <p class="text-gray-600">Upload a CSV to see keywords.</p>
            </div>
        </div>

        <div class="lg:col-span-2 light-card p-6 flex flex-col min-h-[400px] md:min-h-[500px]">
            <div class="flex justify-between items-center mb-4">
                <h2 id="chartTitle" class="brand-h2 text-xl font-semibold">Select a keyword to see visualization</h2>
                <div id="chartBadgesContainer" class="flex"> 
                </div>
            </div>
            <div class="relative flex-grow h-[350px] sm:h-[400px] md:h-[450px] lg:h-[calc(100%-4rem)]">
                <canvas id="cannibalisationChart"></canvas>
            </div>
            <div id="chartError" class="text-red-500 text-center mt-4" style="display: none;"></div>
        </div>
    </div>

    <div class="mt-8 light-card p-6">
        <h2 id="performanceTableTitle" class="brand-h2 text-xl font-semibold mb-4">Performance by URL for Selected Keyword</h2>
        <div id="performanceTableContainer" class="overflow-x-auto">
            <p class="text-gray-600">Select a keyword to see detailed performance data.</p>
        </div>
    </div>

    <div id="highRiskSection" class="mt-8 light-card p-6" style="display: none;">
        <h2 class="brand-h2 text-xl font-semibold mb-4">Pages with High Cannibalization Risk</h2>
        <div id="highRiskCountryFilterContainer" class="mb-4" style="display: none;">
            <label for="highRiskCountryFilterSelect" class="block text-sm font-medium text-gray-700 brand-subtitle mb-1">View Risk by Country:</label>
            <select id="highRiskCountryFilterSelect" class="w-full md:w-1/3 p-2 rounded-md custom-select">
            </select>
        </div>
        <div id="highRiskTableContainer" class="overflow-x-auto">
            <p class="text-gray-600">No high-risk page pairs identified or data not processed.</p>
        </div>
    </div>

    <div id="lookerStudioSection" class="mt-8 light-card p-6">
        <h2 class="brand-h2 text-xl font-semibold mb-4">Looker Studio Dashboard for Data Export</h2>
        <p class="text-gray-600 mb-4">Use the dashboard below to prepare and export the CSV data needed for this tool.</p>
        <div class="w-full rounded-md overflow-hidden border border-[var(--ci-grey)]" style="height: 700px;">
            <iframe
                id="lookerStudioFrame"
                width="100%"
                height="100%"
                src="https://lookerstudio.google.com/embed/reporting/46fe9779-630a-4556-96b2-1742fac7630f/page/F8oLF"
                frameborder="0"
                style="border:0;"
                allowfullscreen
                sandbox="allow-storage-access-by-user-activation allow-scripts allow-same-origin allow-forms allow-popups allow-downloads"
            ></iframe>
        </div>
    </div>

    <footer class="text-center text-sm text-gray-500 mt-12 py-6 border-t border-[var(--ci-grey)]">
        Cut Inside - Keyword Cannibalisation Visualiser
    </footer>

    <script>
        // --- DOM Elements ---
        const csvFileInput = document.getElementById('csvFileInput');
        const fileInfo = document.getElementById('fileInfo');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const keywordFilterInput = document.getElementById('keywordFilterInput');
        const clearFilterButton = document.getElementById('clearFilterButton');
        const keywordCountText = document.getElementById('keywordCountText');
        const metricButtonsContainer = document.getElementById('metricButtons');
        const keywordListContainer = document.getElementById('keywordListContainer');
        const chartTitle = document.getElementById('chartTitle');
        const chartBadgesContainer = document.getElementById('chartBadgesContainer'); 
        const cannibalisationChartCanvas = document.getElementById('cannibalisationChart');
        const chartError = document.getElementById('chartError');
        const performanceTableContainer = document.getElementById('performanceTableContainer');
        const performanceTableTitle = document.getElementById('performanceTableTitle');
        const messageBox = document.getElementById('messageBox');
        const countryFilterContainer = document.getElementById('countryFilterContainer'); 
        const countryFilterSelect = document.getElementById('countryFilterSelect'); 
        const highRiskSection = document.getElementById('highRiskSection');
        const highRiskCountryFilterContainer = document.getElementById('highRiskCountryFilterContainer');
        const highRiskCountryFilterSelect = document.getElementById('highRiskCountryFilterSelect');
        const highRiskTableContainer = document.getElementById('highRiskTableContainer');

        // --- Global State ---
        let rawData = [];
        let keywordDataByCountry = {}; 
        let highCannibalizationRiskData = {}; 
        let chartInstance = null;
        let selectedKeyword = null;
        let selectedMetric = 'Clicks';
        let columnMap = {};
        let availableCountries = new Set(); 
        let countryImpressionsMap = {}; 
        let hasCountryColumn = false; 

        // --- Chart Colors ---
        const CHART_COLORS = [
            '#008080', 
            '#FFCAF7', 
            '#FDD401', 
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
            '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78',
            '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7',
            '#dbdb8d', '#9edae5', '#393b79', '#637939', '#8c6d31', '#843c39',
            '#7b4173', '#5254a3', '#6b6ecf', '#e7cb94', '#cedb9c', '#bd9e39'
        ];

        // --- Event Listeners ---
        csvFileInput.addEventListener('change', handleFileUpload);
        keywordFilterInput.addEventListener('input', filterKeywordList);
        clearFilterButton.addEventListener('click', () => {
            keywordFilterInput.value = '';
            keywordFilterInput.classList.remove('invalid-regex'); 
            filterKeywordList();
        });

        metricButtonsContainer.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                document.querySelectorAll('#metricButtons button').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
                selectedMetric = event.target.dataset.metric;
                if (selectedKeyword) { renderChartAndTable(selectedKeyword); }
            }
        });
        
        countryFilterSelect.addEventListener('change', () => {
            displayKeywordList(); 
            if(selectedKeyword) { renderChartAndTable(selectedKeyword); }
        });
        
        highRiskCountryFilterSelect.addEventListener('change', () => {
            displayHighCannibalizationRiskTable();
        });

        // --- Utility Functions ---
        function showMessage(message, isError = true) {
            messageBox.textContent = message;
            messageBox.style.backgroundColor = isError ? 'var(--ci-yellow)' : 'var(--ci-teal)'; 
            messageBox.style.color = isError ? 'var(--ci-black)' : 'var(--ci-white)';
            messageBox.style.display = 'block';
            setTimeout(() => { messageBox.style.display = 'none'; }, 3000); 
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
        }

        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed'; 
            textarea.style.opacity = '0'; 
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage(`Regex copied: ${text.substring(0,50)}${text.length > 50 ? '...' : ''}`, false);
                } else {
                    showMessage('Failed to copy regex.', true);
                }
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
                showMessage('Failed to copy regex. See console for details.', true);
            }
            document.body.removeChild(textarea);
        }
        
        // --- Core Functions ---
        function resetUIState() {
            keywordListContainer.innerHTML = '<p class="text-gray-600">Upload a CSV file to get started.</p>';
            performanceTableContainer.innerHTML = '<p class="text-gray-600">Upload and select a keyword to see details.</p>';
            performanceTableTitle.textContent = 'Performance by URL for Selected Keyword';
            chartTitle.textContent = 'Upload CSV & Select Keyword';
            chartBadgesContainer.innerHTML = ''; 
            if (chartInstance) chartInstance.destroy();
            keywordCountText.textContent = 'Showing 0 keywords.';
            countryFilterContainer.style.display = 'none';
            countryFilterSelect.innerHTML = '';
            highRiskSection.style.display = 'none';
            highRiskCountryFilterContainer.style.display = 'none';
            highRiskCountryFilterSelect.innerHTML = '';
            highRiskTableContainer.innerHTML = '<p class="text-gray-600">No high-risk page pairs identified or data not processed.</p>';
            availableCountries.clear();
            countryImpressionsMap = {}; 
            hasCountryColumn = false;
            selectedKeyword = null;
            rawData = [];
            keywordDataByCountry = {}; 
            highCannibalizationRiskData = {};
            keywordFilterInput.classList.remove('invalid-regex');
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            resetUIState(); 
            if (!file) { fileInfo.textContent = 'No file selected.'; return; }
            if (!file.name.endsWith('.csv')) { showMessage('Invalid file type. Please upload a CSV file.'); csvFileInput.value = ''; return; }
            fileInfo.textContent = `File: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
            loadingIndicator.style.display = 'block';
            chartError.style.display = 'none';
            try {
                const csvText = await file.text();
                parseAndProcessCSV(csvText);
            } catch (error) {
                console.error("Error reading or processing file:", error);
                showMessage(`Error processing file: ${error.message}`);
                resetUIState(); 
                keywordListContainer.innerHTML = '<p class="text-red-500">Error processing file.</p>';
            } finally { loadingIndicator.style.display = 'none'; }
        }

        function parseAndProcessCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) { showMessage('CSV file is empty or has no data rows.'); keywordListContainer.innerHTML = '<p class="text-red-500">CSV file is empty.</p>'; return; }
            const headerRow = lines[0].trim();
            const headers = headerRow.split(',').map(h => h.trim());
            columnMap = {};
            const knownHeaders = {
                query: ['query', 'keyword', 'top queries'], page: ['page', 'landing page', 'url'], date: ['date'],
                country: ['country', 'countries'], clicks: ['clicks', 'url clicks'], impressions: ['impressions'],
                ctr: ['ctr', 'click through rate', 'url ctr'], position: ['position', 'average position']
            };
            for (const key in knownHeaders) {
                for (const alias of knownHeaders[key]) {
                    const index = headers.findIndex(h => h.toLowerCase() === alias.toLowerCase());
                    if (index !== -1) { columnMap[key] = index; break; }
                }
            }
            hasCountryColumn = typeof columnMap.country !== 'undefined';
            const requiredKeys = ['query', 'page', 'date', 'clicks', 'impressions'];
            for (const reqKey of requiredKeys) {
                if (typeof columnMap[reqKey] === 'undefined') {
                    showMessage(`Required column "${reqKey}" not found. Headers: ${headers.join(', ')}`);
                    keywordListContainer.innerHTML = `<p class="text-red-500">Missing: ${reqKey}.</p>`; return;
                }
            }
            rawData = []; availableCountries.clear(); countryImpressionsMap = {};
            const rowRegex = /(?:^|,)(\"(?:[^\"]+|\"\")*\"|[^,]*)/g;
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                const values = []; let match;
                while (match = rowRegex.exec(lines[i])) {
                    let value = match[1]; if (value.startsWith('"') && value.endsWith('"')) value = value.substring(1, value.length - 1).replace(/""/g, '"');
                    values.push(value);
                }
                if (values.length >= headers.length) {
                    const row = {};
                    row.Query = values[columnMap.query] || ''; row.Page = values[columnMap.page] || ''; row.Date = values[columnMap.date] || '';
                    row.Clicks = parseInt(values[columnMap.clicks]) || 0; row.Impressions = parseInt(values[columnMap.impressions]) || 0;
                    row.Country = hasCountryColumn ? (values[columnMap.country] || 'Unknown').trim() : 'N/A';
                    if (hasCountryColumn && row.Country && row.Country !== 'Unknown' && row.Country !== '') availableCountries.add(row.Country);
                    const ctrV = values[columnMap.ctr]; if (ctrV && ctrV.includes('%')) row.CTR = parseFloat(ctrV.replace('%',''))/100; else if (ctrV) row.CTR = parseFloat(ctrV)||0; else row.CTR = 0;
                    row.Position = parseFloat(values[columnMap.position]) || 0;
                    if (row.Query && row.Page && row.Date) rawData.push(row);
                }
            }
            if (rawData.length === 0) { showMessage('No valid data rows in CSV.'); keywordListContainer.innerHTML = '<p class="text-red-500">No valid data.</p>'; return; }
            
            generateKeywordDataByCountry(); 
            processDataForHighCannibalizationRisk(); 
            displayKeywordList(); 
            displayHighCannibalizationRiskTable(); 
            showMessage('CSV processed successfully!', false);
        }

        function generateKeywordDataByCountry() {
            keywordDataByCountry = {}; countryImpressionsMap = { 'All Countries': 0 }; 
            const groupedByCountryAndQuery = {};
            rawData.forEach(row => {
                const countryKey = row.Country;
                countryImpressionsMap[countryKey] = (countryImpressionsMap[countryKey] || 0) + row.Impressions;
                countryImpressionsMap['All Countries'] += row.Impressions;
                if (!groupedByCountryAndQuery[countryKey]) groupedByCountryAndQuery[countryKey] = {};
                if (!groupedByCountryAndQuery[countryKey][row.Query]) groupedByCountryAndQuery[countryKey][row.Query] = [];
                groupedByCountryAndQuery[countryKey][row.Query].push(row);
            });
            for (const country in groupedByCountryAndQuery) {
                if (!keywordDataByCountry[country]) keywordDataByCountry[country] = {};
                for (const query in groupedByCountryAndQuery[country]) {
                    const queryRowsInCountry = groupedByCountryAndQuery[country][query];
                    const uniquePagesInCountryForQuery = new Set(queryRowsInCountry.map(r => r.Page));
                    if (uniquePagesInCountryForQuery.size > 1) {
                        let totalImpressionsForQueryInCountry = 0; let dUHCIC = false; let mPGCIC = false; const aDSFQIC = new Set();
                        queryRowsInCountry.forEach(r => { totalImpressionsForQueryInCountry += r.Impressions; aDSFQIC.add(r.Date); });
                        const sortedDates = Array.from(aDSFQIC).sort((a, b) => new Date(a) - new Date(b)); let pDU = null;
                        sortedDates.forEach(date => {
                            const rOD = queryRowsInCountry.filter(r => r.Date === date); let cDU = null; let mCOD = -1; let pWCOD = 0; const pOD = new Set(); rOD.forEach(r => pOD.add(r.Page));
                            pOD.forEach(page => { const cFPOD = rOD.filter(r => r.Page === page).reduce((s, r) => s + r.Clicks, 0); if (cFPOD > 0) pWCOD++; if (cFPOD > mCOD) { mCOD = cFPOD; cDU = page; } });
                            if (pWCOD >= 2) mPGCIC = true; if (pDU && cDU && cDU !== pDU && mCOD > 0) dUHCIC = true; if (cDU && mCOD > 0) pDU = cDU;
                        });
                        keywordDataByCountry[country][query] = { impressions: totalImpressionsForQueryInCountry, dominantUrlHasChanged: dUHCIC, multiplePagesGotClicks: mPGCIC };
                    }
                }
            }
        }
        
        function processDataForHighCannibalizationRisk() {
            highCannibalizationRiskData = {}; const groupedByCountryQuery = {};
            rawData.forEach(row => {
                const countryKey = row.Country;
                if (!groupedByCountryQuery[countryKey]) groupedByCountryQuery[countryKey] = {};
                if (!groupedByCountryQuery[countryKey][row.Query]) groupedByCountryQuery[countryKey][row.Query] = [];
                groupedByCountryQuery[countryKey][row.Query].push(row);
            });
            for (const country in groupedByCountryQuery) {
                if (!highCannibalizationRiskData[country]) highCannibalizationRiskData[country] = {};
                for (const query in groupedByCountryQuery[country]) {
                    const queryRows = groupedByCountryQuery[country][query]; const uniquePages = [...new Set(queryRows.map(r => r.Page))];
                    if (uniquePages.length > 1) {
                        for (let i = 0; i < uniquePages.length; i++) {
                            for (let j = i + 1; j < uniquePages.length; j++) {
                                const page1 = uniquePages[i]; const page2 = uniquePages[j]; const pairKey = [page1, page2].sort().join('|');
                                if (!highCannibalizationRiskData[country][pairKey]) {
                                    highCannibalizationRiskData[country][pairKey] = { page1: [page1, page2].sort()[0], page2: [page1, page2].sort()[1], competingKeywordCount: 0, page1ClicksTotal: 0, page2ClicksTotal: 0, page1ImpressionsTotal: 0, page2ImpressionsTotal: 0, keywords: new Set() };
                                }
                                const pairData = highCannibalizationRiskData[country][pairKey]; pairData.keywords.add(query);
                                queryRows.forEach(row => { if (row.Page === page1) { pairData.page1ClicksTotal += row.Clicks; pairData.page1ImpressionsTotal += row.Impressions; } else if (row.Page === page2) { pairData.page2ClicksTotal += row.Clicks; pairData.page2ImpressionsTotal += row.Impressions; } });
                            }
                        }
                    }
                }
                for (const pairKey in highCannibalizationRiskData[country]) {
                    const entry = highCannibalizationRiskData[country][pairKey]; entry.competingKeywordCount = entry.keywords.size;
                    const totalPairClicks = entry.page1ClicksTotal + entry.page2ClicksTotal; const totalPairImpressions = entry.page1ImpressionsTotal + entry.page2ImpressionsTotal;
                    entry.page1ClickShare = totalPairClicks > 0 ? (entry.page1ClicksTotal / totalPairClicks) * 100 : 0; entry.page2ClickShare = totalPairClicks > 0 ? (entry.page2ClicksTotal / totalPairClicks) * 100 : 0;
                    entry.page1ImpressionShare = totalPairImpressions > 0 ? (entry.page1ImpressionsTotal / totalPairImpressions) * 100 : 0; entry.page2ImpressionShare = totalPairImpressions > 0 ? (entry.page2ImpressionsTotal / totalPairImpressions) * 100 : 0;
                }
            }
        }

        function generateChartData(query, targetCountry) {
            let filteredRawData = rawData.filter(row => row.Query === query);
            if (hasCountryColumn && targetCountry && targetCountry !== 'All Countries') {
                filteredRawData = filteredRawData.filter(row => row.Country === targetCountry);
            } else if (!hasCountryColumn && targetCountry === 'N/A') { 
                 filteredRawData = filteredRawData.filter(row => row.Country === 'N/A');
            } 
            const displayData = { urls: {}, allDates: new Set(), dominantUrlHasChanged: false, multiplePagesGotClicks: false };
            const tempUrlsData = {};
            filteredRawData.forEach(row => {
                if (!tempUrlsData[row.Page]) tempUrlsData[row.Page] = [];
                tempUrlsData[row.Page].push({date: row.Date, clicks: row.Clicks, impressions: row.Impressions, ctr: row.CTR, position: row.Position});
                displayData.allDates.add(row.Date);
            });
            displayData.allDates = Array.from(displayData.allDates).sort((a,b) => new Date(a) - new Date(b));
            const pagesInView = Object.keys(tempUrlsData);
            if (pagesInView.length === 0 && filteredRawData.length > 0 && targetCountry !== 'All Countries' && targetCountry !== 'N/A') { 
                 return { ...displayData, urls: {}, allDates: [], noDataForFilter: true};
            }
            for (const page in tempUrlsData) { displayData.urls[page] = tempUrlsData[page].sort((a,b) => new Date(a.date) - new Date(b.date)); }
            let prevDomUrl = null;
            displayData.allDates.forEach(date => {
                let currentDomUrl = null; let maxClicks = -1; let pagesWithClicksThisDate = 0;
                pagesInView.forEach(page => {
                    const dp = displayData.urls[page]?.find(d => d.date === date);
                    if (dp) { if (dp.clicks > 0) pagesWithClicksThisDate++; if (dp.clicks > maxClicks) { maxClicks = dp.clicks; currentDomUrl = page; } }
                });
                if (pagesWithClicksThisDate >= 2) displayData.multiplePagesGotClicks = true;
                if (prevDomUrl && currentDomUrl && currentDomUrl !== prevDomUrl && maxClicks > 0) displayData.dominantUrlHasChanged = true;
                if (currentDomUrl && maxClicks > 0) prevDomUrl = currentDomUrl;
            });
            return displayData;
        }

        function displayKeywordList() {
            keywordListContainer.innerHTML = '';
            const selectedCountry = hasCountryColumn ? countryFilterSelect.value : 'N/A';
            let keywordsToDisplay = [];

            if (selectedCountry === 'All Countries') {
                const globalKeywordSummary = {};
                rawData.forEach(row => {
                    if (!globalKeywordSummary[row.Query]) globalKeywordSummary[row.Query] = { impressions: 0, pages: new Set(), dates: new Set(), rows: [] };
                    globalKeywordSummary[row.Query].impressions += row.Impressions; globalKeywordSummary[row.Query].pages.add(row.Page); globalKeywordSummary[row.Query].dates.add(row.Date); globalKeywordSummary[row.Query].rows.push(row);
                });
                for (const query in globalKeywordSummary) {
                    if (globalKeywordSummary[query].pages.size > 1) {
                        let dUHCO = false; let mPGCO = false; const sD = Array.from(globalKeywordSummary[query].dates).sort((a,b)=>new Date(a)-new Date(b)); let pDU = null;
                        sD.forEach(date => {
                            const rOD = globalKeywordSummary[query].rows.filter(r => r.Date === date); let cDU = null; let mCOD = -1; let pWCOD = 0; const dPOD = new Set(rOD.map(r => r.Page));
                            dPOD.forEach(page => { const c = rOD.filter(r=>r.Page === page).reduce((s,r)=>s+r.Clicks,0); if(c>0)pWCOD++; if(c>mCOD){mCOD=c;cDU=page;} });
                            if(pWCOD>=2)mPGCO=true; if(pDU&&cDU&&cDU!==pDU&&mCOD>0)dUHCO=true; if(cDU&&mCOD>0)pDU=cDU;
                        });
                        keywordsToDisplay.push({ query: query, impressions: globalKeywordSummary[query].impressions, dominantUrlHasChanged: dUHCO, multiplePagesGotClicks: mPGCO });
                    }
                }
            } else { 
                const countryData = keywordDataByCountry[selectedCountry] || {};
                for (const query in countryData) {
                    if (countryData[query].impressions > 0) {
                         keywordsToDisplay.push({ query: query, impressions: countryData[query].impressions, dominantUrlHasChanged: countryData[query].dominantUrlHasChanged, multiplePagesGotClicks: countryData[query].multiplePagesGotClicks });
                    }
                }
            }
            
            const filterText = keywordFilterInput.value;
            let filterRegex = null;
            let isRegexValid = true;
            if (filterText) {
                try {
                    filterRegex = new RegExp(filterText, 'i'); 
                    keywordFilterInput.classList.remove('invalid-regex');
                } catch (e) {
                    isRegexValid = false;
                    keywordFilterInput.classList.add('invalid-regex');
                }
            } else {
                 keywordFilterInput.classList.remove('invalid-regex');
            }

            keywordsToDisplay = keywordsToDisplay.filter(item => {
                if (!filterText) return true; 
                if (isRegexValid && filterRegex) {
                    return filterRegex.test(item.query);
                } else if (!isRegexValid) { 
                    return item.query.toLowerCase().includes(filterText.toLowerCase()); 
                }
                return item.query.toLowerCase().includes(filterText.toLowerCase()); 
            });

            keywordsToDisplay.sort((a, b) => b.impressions - a.impressions);
            const totalKeywordsInCurrentScope = selectedCountry === 'All Countries' ? keywordsToDisplay.length : Object.keys(keywordDataByCountry[selectedCountry] || {}).length;
            keywordCountText.textContent = `Showing ${keywordsToDisplay.length} of ${totalKeywordsInCurrentScope} keywords with multiple URLs` + (selectedCountry !== 'All Countries' && selectedCountry !== 'N/A' ? ` in ${selectedCountry}` : (selectedCountry === 'N/A' && !hasCountryColumn ? '' : ' (overall)'));
            if (keywordsToDisplay.length === 0) {
                const countryMsg = (selectedCountry !== 'All Countries' && selectedCountry !== 'N/A') ? ` in ${selectedCountry}` : (selectedCountry === 'N/A' && !hasCountryColumn ? '' : ' (overall)');
                keywordListContainer.innerHTML = `<p class="text-gray-600">No keywords with multiple URLs found${countryMsg}.</p>`;
            } else {
                 keywordsToDisplay.forEach(keywordItem => {
                    const listItem = document.createElement('div'); listItem.className = 'keyword-item p-2 rounded-md cursor-pointer text-sm flex justify-between items-center w-full'; listItem.dataset.query = keywordItem.query;
                    const textContentDiv = document.createElement('div'); textContentDiv.className = 'flex items-center overflow-hidden mr-2 flex-grow';
                    const queryNameSpan = document.createElement('span'); queryNameSpan.textContent = keywordItem.query; queryNameSpan.className = 'truncate mr-2';
                    const impressionsSpan = document.createElement('span'); impressionsSpan.textContent = `${keywordItem.impressions.toLocaleString()} impr.`; impressionsSpan.className = 'text-xs text-gray-500'; 
                    textContentDiv.appendChild(queryNameSpan); textContentDiv.appendChild(impressionsSpan); listItem.appendChild(textContentDiv);
                    const badgeContainerEl = document.createElement('div'); badgeContainerEl.className = 'badge-container flex-shrink-0';
                    const badgeTooltipSuffix = (selectedCountry !== 'All Countries' && selectedCountry !== 'N/A') ? ` in ${selectedCountry}` : ' (overall)';
                    if (keywordItem.dominantUrlHasChanged) { const b = document.createElement('span'); b.className = 'badge-warning text-xs font-semibold px-1.5 py-0.5 rounded-full tooltip'; b.textContent = '!'; const tt = document.createElement('span'); tt.className = 'tooltiptext'; tt.textContent = `Dominant URL changed${badgeTooltipSuffix}`; b.appendChild(tt); badgeContainerEl.appendChild(b); }
                    if (keywordItem.multiplePagesGotClicks) { const b = document.createElement('span'); b.className = 'badge-cannibalization text-xs font-semibold px-1.5 py-0.5 rounded-full tooltip'; b.textContent = 'C'; const tt = document.createElement('span'); tt.className = 'tooltiptext'; tt.textContent = `Multiple pages got clicks${badgeTooltipSuffix}`; b.appendChild(tt); badgeContainerEl.appendChild(b); }
                    if(badgeContainerEl.hasChildNodes()){ listItem.appendChild(badgeContainerEl); }
                    listItem.addEventListener('click', () => { document.querySelectorAll('#keywordListContainer .keyword-item').forEach(item => item.classList.remove('active')); listItem.classList.add('active'); selectedKeyword = keywordItem.query; renderChartAndTable(keywordItem.query); });
                    keywordListContainer.appendChild(listItem);
                });
            }
            if (hasCountryColumn && availableCountries.size > 0) {
                const currentChartCountryVal = countryFilterSelect.value;
                countryFilterSelect.innerHTML = `<option value="All Countries">All Countries (${countryImpressionsMap['All Countries'] ? countryImpressionsMap['All Countries'].toLocaleString() : 0} impr.)</option>`;
                Array.from(availableCountries).sort().forEach(country => { const o = document.createElement('option'); o.value = country; o.textContent = `${country} (${countryImpressionsMap[country] ? countryImpressionsMap[country].toLocaleString() : 0} impr.)`; countryFilterSelect.appendChild(o); });
                countryFilterSelect.value = currentChartCountryVal || "All Countries"; countryFilterContainer.style.display = 'block';
                const currentHighRiskCountryVal = highRiskCountryFilterSelect.value; highRiskCountryFilterSelect.innerHTML = '';
                 if (availableCountries.size > 0) {
                    Array.from(availableCountries).sort().forEach(country => { const o = document.createElement('option'); o.value = country; o.textContent = `${country} (${countryImpressionsMap[country] ? countryImpressionsMap[country].toLocaleString() : 0} impr.)`; highRiskCountryFilterSelect.appendChild(o); });
                    highRiskCountryFilterSelect.value = currentHighRiskCountryVal || (highRiskCountryFilterSelect.options.length > 0 ? highRiskCountryFilterSelect.options[0].value : ''); highRiskCountryFilterContainer.style.display = 'block';
                } else { highRiskCountryFilterContainer.style.display = 'none'; }
            } else { countryFilterContainer.style.display = 'none'; highRiskCountryFilterContainer.style.display = 'none'; }
        }
        
        function filterKeywordList() { displayKeywordList(); }
        
        function updateChartBadges(displayData) {
            chartBadgesContainer.innerHTML = ''; if (!displayData) return;
            if (displayData.dominantUrlHasChanged) { const b = document.createElement('span'); b.className = 'badge-warning text-xs font-semibold px-2 py-1 rounded-full tooltip'; b.textContent = '!'; const tt = document.createElement('span'); tt.className = 'tooltiptext'; tt.textContent = 'Dominant URL changed in this view'; b.appendChild(tt); chartBadgesContainer.appendChild(b); }
            if (displayData.multiplePagesGotClicks) { const b = document.createElement('span'); b.className = 'badge-cannibalization text-xs font-semibold px-2 py-1 rounded-full tooltip'; b.textContent = 'C'; const tt = document.createElement('span'); tt.className = 'tooltiptext'; tt.textContent = 'Multiple pages got clicks in this view'; b.appendChild(tt); chartBadgesContainer.appendChild(b); }
        }

        function renderChartAndTable(query) {
            const selectedCountryValue = hasCountryColumn ? countryFilterSelect.value : 'N/A';
            const displayData = generateChartData(query, selectedCountryValue);
            const countryText = (hasCountryColumn && selectedCountryValue !== 'All Countries' && selectedCountryValue !== 'N/A') ? ` in ${selectedCountryValue}` : '';
            if (!displayData || (displayData.noDataForFilter && Object.keys(displayData.urls).length === 0)) {
                chartTitle.textContent = `No data for: ${query}${countryText}`; performanceTableTitle.textContent = `No data for ${query}${countryText}`;
                chartError.textContent = `No data available for the selected keyword${countryText}.`; chartError.style.display = 'block'; if (chartInstance) chartInstance.destroy();
                performanceTableContainer.innerHTML = `<p class="text-gray-600">${chartError.textContent}</p>`; updateChartBadges(null); return;
            }
            chartError.style.display = 'none'; chartTitle.textContent = `Visualisation for: ${query}${countryText}`; performanceTableTitle.textContent = `Performance by URL for ${query}${countryText}`; updateChartBadges(displayData);
            const labels = displayData.allDates; const datasets = []; let colorIndex = 0; const urlPerformanceDetails = []; let viewTotalClicks = 0; let viewTotalImpressions = 0;
            Object.keys(displayData.urls).forEach(url => { let urlTC=0,urlTI=0; displayData.urls[url].forEach(dp=>{urlTC+=dp.clicks;urlTI+=dp.impressions;}); viewTotalClicks+=urlTC; viewTotalImpressions+=urlTI; });
            Object.keys(displayData.urls).forEach(url => {
                const udp = displayData.urls[url]; const md = labels.map(date => { const p = udp.find(dp => dp.date === date); if (!p) return null; switch (selectedMetric) { case 'Clicks': return p.clicks; case 'Impressions': return p.impressions; case 'CTR': return p.ctr * 100; case 'Position': return p.position === 0 ? null : p.position; default: return null; } });
                datasets.push({ label: url.length > 50 ? '...' + url.slice(-47) : url, data: md, borderColor: CHART_COLORS[colorIndex % CHART_COLORS.length], backgroundColor: CHART_COLORS[colorIndex % CHART_COLORS.length] + 'BF', tension: 0.1, fill: false, pointRadius: 3, pointHoverRadius: 6, spanGaps: true }); colorIndex++;
                let tc=0,ti=0,twp=0,icfp=0; let fs = labels.length > 0 ? labels[labels.length -1] : "N/A";
                udp.forEach(dp => { tc+=dp.clicks; ti+=dp.impressions; if(dp.position>0&&dp.impressions>0){twp+=dp.position*dp.impressions;icfp+=dp.impressions;} if(new Date(dp.date)<new Date(fs)||fs==="N/A")fs=dp.date; });
                const ac=ti>0?(tc/ti):0; const ap=icfp>0?(twp/icfp):0;
                urlPerformanceDetails.push({ url:url,totalClicks:tc,clickShare:viewTotalClicks>0?(tc/viewTotalClicks)*100:0,totalImpressions:ti,impressionShare:viewTotalImpressions>0?(ti/viewTotalImpressions)*100:0,avgCtr:ac*100,avgPosition:ap,firstSeen:fs });
            });
            urlPerformanceDetails.sort((a,b) => b.totalClicks - a.totalClicks);
            if (chartInstance) chartInstance.destroy();
            const chartOptions = { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, 
                scales: { 
                    y: { beginAtZero: selectedMetric !== 'Position', reverse: selectedMetric === 'Position', title: { display: true, text: selectedMetric, color: 'var(--ci-black)', font: { family: "'Montserrat', sans-serif" } }, grid: { color: 'var(--ci-grey)' }, ticks: { color: 'var(--ci-black)', font: { family: "'Montserrat', sans-serif" } } }, 
                    x: { title: { display: true, text: 'Date', color: 'var(--ci-black)', font: { family: "'Montserrat', sans-serif" } }, grid: { display: false }, ticks: { color: 'var(--ci-black)', font: { family: "'Montserrat', sans-serif" }, maxRotation: 45, minRotation: 45 } } 
                }, 
                plugins: { 
                    legend: { position: 'top', labels: { color: 'var(--ci-black)', font: { family: "'Montserrat', sans-serif" } } }, 
                    tooltip: { 
                        backgroundColor: 'var(--ci-black)', titleColor: 'var(--ci-white)', bodyColor: 'var(--ci-white)', 
                        borderColor: 'var(--ci-teal)', borderWidth: 1, titleFont: { family: "'Montserrat', sans-serif" }, bodyFont: { family: "'Montserrat', sans-serif" }
                    } 
                } 
            };
            chartInstance = new Chart(cannibalisationChartCanvas, { type: 'line', data: { labels: labels, datasets: datasets }, options: chartOptions });
            renderPerformanceTable(urlPerformanceDetails);
        }

        function renderPerformanceTable(details) {
            performanceTableContainer.innerHTML = '';
            if (details.length === 0) { performanceTableContainer.innerHTML = '<p class="text-gray-600">No performance data for this keyword/filter.</p>'; return; }
            const table = document.createElement('table'); table.className = 'min-w-full divide-y divide-[var(--ci-grey)] text-sm'; 
            table.innerHTML = `<thead class="text-left text-[var(--ci-black)] brand-subtitle"><tr class="border-b border-[var(--ci-grey)]"> 
                <th class="px-4 py-3">URL</th> <th class="px-4 py-3 text-right">Total Clicks</th> <th class="px-4 py-3 text-right">Click Share</th>
                <th class="px-4 py-3 text-right">Total Impressions</th> <th class="px-4 py-3 text-right">Imp. Share</th> <th class="px-4 py-3 text-right">Avg. CTR</th>
                <th class="px-4 py-3 text-right">Avg. Position</th> <th class="px-4 py-3">First Seen</th>
                </tr></thead><tbody class="divide-y divide-[var(--ci-grey)]"></tbody>`; 
            const tbody = table.querySelector('tbody');
            details.forEach(item => {
                const row = tbody.insertRow(); row.className = 'hover:bg-[var(--ci-pattens-blue)]'; 
                const urlText = item.url.length > 60 ? item.url.substring(0,28) + '...' + item.url.substring(item.url.length - 29) : item.url;
                const urlCellHTML = `<a href="${item.url}" target="_blank" class="table-url-link" title="${item.url}">${urlText}</a>`;
                row.innerHTML = `<td class="px-4 py-2 whitespace-nowrap">${urlCellHTML}</td><td class="px-4 py-2 text-right">${item.totalClicks.toLocaleString()}</td> <td class="px-4 py-2 text-right">${item.clickShare.toFixed(2)}%</td><td class="px-4 py-2 text-right">${item.totalImpressions.toLocaleString()}</td> <td class="px-4 py-2 text-right">${item.impressionShare.toFixed(2)}%</td><td class="px-4 py-2 text-right">${item.avgCtr.toFixed(2)}%</td> <td class="px-4 py-2 text-right">${item.avgPosition > 0 ? item.avgPosition.toFixed(2) : 'N/A'}</td><td class="px-4 py-2 whitespace-nowrap">${item.firstSeen}</td>`;
            });
            performanceTableContainer.appendChild(table);
        }
        
        function displayHighCannibalizationRiskTable() {
            highRiskTableContainer.innerHTML = '';
            const selectedRiskCountry = hasCountryColumn ? highRiskCountryFilterSelect.value : 'N/A';
            const riskDataForCountry = highCannibalizationRiskData[selectedRiskCountry];
            if (!riskDataForCountry || Object.keys(riskDataForCountry).length === 0) {
                highRiskTableContainer.innerHTML = `<p class="text-gray-600">No high-risk page pairs identified for ${selectedRiskCountry === 'N/A' ? 'the uploaded data' : selectedRiskCountry}.</p>`;
                highRiskSection.style.display = Object.keys(highCannibalizationRiskData).length > 0 ? 'block' : 'none'; 
                return;
            }
            let riskPairs = Object.values(riskDataForCountry);
            riskPairs = riskPairs.filter(pair => pair.competingKeywordCount > 0);
            riskPairs.sort((a, b) => b.competingKeywordCount - a.competingKeywordCount); 
            if (riskPairs.length === 0) {
                 highRiskTableContainer.innerHTML = `<p class="text-gray-600">No high-risk page pairs with competing keywords for ${selectedRiskCountry === 'N/A' ? 'the uploaded data' : selectedRiskCountry}.</p>`;
                 highRiskSection.style.display = 'block'; return;
            }
            const table = document.createElement('table'); table.className = 'min-w-full divide-y divide-[var(--ci-grey)] text-sm'; 
            table.innerHTML = `<thead class="text-left text-[var(--ci-black)] brand-subtitle"><tr class="border-b border-[var(--ci-grey)]"> 
                <th class="px-4 py-3">Page 1</th><th class="px-4 py-3">Page 2</th><th class="px-4 py-3 text-right">Competing Keywords</th>
                <th class="px-4 py-3 text-center">Click Share (P1 / P2)</th><th class="px-4 py-3 text-center">Impression Share (P1 / P2)</th>
                </tr></thead><tbody class="divide-y divide-[var(--ci-grey)]"></tbody>`; 
            const tbody = table.querySelector('tbody');
            riskPairs.forEach(pair => {
                const row = tbody.insertRow(); 
                row.className = 'hover:bg-[var(--ci-pattens-blue)]'; 

                const page1Cell = row.insertCell();
                page1Cell.className = 'px-4 py-2 whitespace-nowrap';
                const page1Text = pair.page1.length > 40 ? pair.page1.substring(0,18) + '...' + pair.page1.substring(pair.page1.length - 19) : pair.page1;
                page1Cell.innerHTML = `<a href="${pair.page1}" target="_blank" class="table-url-link" title="${pair.page1}">${page1Text}</a>`;

                const page2Cell = row.insertCell();
                page2Cell.className = 'px-4 py-2 whitespace-nowrap';
                const page2Text = pair.page2.length > 40 ? pair.page2.substring(0,18) + '...' + pair.page2.substring(pair.page2.length - 19) : pair.page2;
                page2Cell.innerHTML = `<a href="${pair.page2}" target="_blank" class="table-url-link" title="${pair.page2}">${page2Text}</a>`;
                
                const keywordCountCell = row.insertCell();
                keywordCountCell.className = 'px-4 py-2 text-right';
                const keywordCountSpan = document.createElement('span');
                keywordCountSpan.className = 'clickable-count tooltip';
                keywordCountSpan.innerHTML = `${pair.competingKeywordCount}<span class="tooltiptext">Keywords: ${Array.from(pair.keywords).slice(0,3).join(', ')}${pair.keywords.size > 3 ? '...' : ''} (Click to copy regex)</span>`;
                keywordCountSpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const keywordsArray = Array.from(pair.keywords);
                    if (keywordsArray.length > 0) {
                        const regexString = keywordsArray.map(k => escapeRegExp(k)).join('|');
                        copyToClipboard(regexString);
                    } else { showMessage('No keywords to copy.', true); }
                });
                keywordCountCell.appendChild(keywordCountSpan);

                const clickShareCell = row.insertCell();
                clickShareCell.className = 'px-4 py-2 text-center';
                clickShareCell.textContent = `${pair.page1ClickShare.toFixed(1)}% / ${pair.page2ClickShare.toFixed(1)}%`;

                const impressionShareCell = row.insertCell();
                impressionShareCell.className = 'px-4 py-2 text-center';
                impressionShareCell.textContent = `${pair.page1ImpressionShare.toFixed(1)}% / ${pair.page2ImpressionShare.toFixed(1)}%`;
            });
            highRiskTableContainer.appendChild(table);
            highRiskSection.style.display = 'block';
        }

        resetUIState();
    </script>
</body>
</html>
